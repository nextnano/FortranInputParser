# Input parser Manual

The given input parser reads and analyzes an input file according to predefined syntactical rules.
It is written in Fortran 2003.

The main idea is to realize a tool, which enables the user to write position independent (as far as possible) input files.
The input files can be changed without recompiling the parser.
The parser checks the input file for syntactical correctness, for the presence of required input and for correctness of the data types of the given variable values.

Additionally, functions and variables are supported.

The input parser can be read in several times during a program run, i.e. it is possible to read in an input file which was modified and generated by the program running it.


## Parser usage

To read and analyze the input file, a call to SUBROUTINE read_and_analyze_input is required. No argument list is required.

*Data value extraction*

To extract data for a given specifier, a generic subroutine get_data(....) is supplied.

```
SUBROUTINE get_data(keyword,new,specifier,cont,data,pres,line,last)
```

In the calling routine, two modules must be included by the USE statement:

```
USE parameters, ONLY: Data_len
USE generic_get_data
```
length specification for character variables keyword and specifier
interface to generic subroutine get_data(....)

Argument list: Input variables
```
LOGICAL               :: new
LOGICAL               :: cont
CHARACTER(Data_len/3) :: keyword
CHARACTER(Data_len/3) :: specifier 
```

new: .TRUE.  start new search for keyword
new: .FALSE. stay at actual keyword
At first entry in subroutine get_data new must be set to .TRUE.
cont
.TRUE.  search for specifier in next input sequence
.FALSE. search in actual input sequence
keyword
string, containing keyword to be searched for (maximum length 267/3)
specifier
string, containing specifier, for which data value is requested (maximum length 267/3)

Informative output variables:

```
INTEGER :: line
LOGICAL :: pres
LOGICAL :: last 
```

line: line number in input file, where value was found.
pres: .TRUE. if a value for actual specifier was found; .FALSE. otherwise
last: .TRUE. if last input sequence for given keyword was read.

*Generic output*

The variable data in the argument list is representative for one of the possible data type listed beneath for a generic call.

```
INTEGER                       :: ival
REAL(4)                       :: xsval   ! single
LOGICAL                       :: loval
REAL(8)                       :: xdval   ! double
CHARACTER(Data_len/3)         :: caval
INTEGER, DIMENSION(:),POINTER :: inarval
REAL(4), DIMENSION(:),POINTER :: xsarval ! single
REAL(8), DIMENSION(:),POINTER :: xdarval ! double
```

The generic argument must be of the same type as the data type of the requested specifier.


## Input parser: General program flow

This is a description how the main driving routine (MODULE input_driver_module) works (used for reading input parameters, database information as well as processing and checking the corresponding quantities).
The main driving routine for reading input parameters, database information as well as processing and checking the corresponding quantities is input_driver.f90.

```
!---------------------------------------------------!
    CALL read_and_analyze_input                     ! file: parser.f90 
!---------------------------------------------------!
! requires only modules contained in file parser.f90

!---------------------------------------------------!
    CALL d_read_and_analyze_input                   ! file: data_base_builder.f90 
!---------------------------------------------------!
! requires only modules contained in file data_base_builder.f90

!---------------------------------------------------!
    CALL warnings_on_off(warning)                   ! file: warnings_on_off.f90 
!---------------------------------------------------!

!---------------------------------------------------!
    CALL read_constants_and_scaling                 !
!        file: read_constants_and_scaling.f90 
!---------------------------------------------------!
```

## Input parser: Keywords - General introduction to some of the keywords and specifiers including some examples

*Specification of input file name*

The specification of the input filename is done as a first entry in file keywords.val as follows:

```
!---------------------------------------------------!
$input_filename                        optional     !
 input-filename         character      optional     !
$end_input_filename                    optional     !
!---------------------------------------------------!
```

Example

```
!---------------------------------------------------!
$input_filename                        optional     !
 my_input_file.in       character      optional     ! Reads in "my_input_file.in".
$end_input_filename                    optional     !
!---------------------------------------------------!
```
