# Input parser manual

This input parser reads and analyzes an input file according to predefined syntactical rules.
It is written in Fortran.

The main idea is to realize a tool, which enables the user to write position independent (as far as possible) input files.
The input files can be changed without recompiling the parser.
The parser checks the input file for syntactical correctness, for the presence of required input and for correctness of the data types of the given variable values.

Additionally, functions and variables are supported.

The input parser can be read in several times during a program run, i.e. it is possible to read in an input file which was modified and generated by the program running it.

Any input must be given according to predefined syntactical rules.
These rules utilize keywords and specifiers, defined in a file, currently named keywords.val.
The name of this file is specified in module parameters in the parser source code.
New keywords and specifiers can be added without the need of recompilation.
The general syntax to define keywords and specifiers in keywords.val is as follows:

```
keyword
 specifier1    data type   optional
 specifier2    data type   optional
 specifier3    data type   optional
 ...
end_keyword
```

*Limitations for keywords and specifiers*

Special characters used to identify a keyword are defined in module parameters.

*keyword*

Each keyword must start with a predefined special character.
This special character is currently set to $ (but can be changed) and is allowed only as the first character of a keyword.
Otherwise, the keyword is an arbitrary string, containing no blanks and no "=" signs.

*specifier*

Arbitrary string, containing no blanks, no "$" (which is the special character of the *keyword*), and no "=" sign.

*end_keyword*

Must match the starting keyword as follows: $keyword -> $end_keyword

*data_type*

Each specifier has a fixed data type.
This data type must be defined by a string in the keyword definition file at the position of *data type*.

The following data types are supported:

```
integer:       integer number
real:          single precision real number
double:        double precision real number
character:     character string
logical:       boolean (.TRUE./.FALSE.)
integer_array: array of integer numbers
real_array:    array of single precision real numbers
double_array:  array of double precision real numbers
```

*optional*

Defines specifier to be optional input or required input.
For the string optional one of the two logical values must be substituted.

```
optional specifier is optional input (meaning .FALSE.)
required specifier is required input (meaning .TRUE.)
```

*Input file name*

The input file name is specified due to the first entry sequence in file keywords.val.
This must look like (everything after the "!" is just comment and can be removed):

```
! only to specify input file name
!----------------------------------------
$input_filename
 my_input_file.in    character   required
$end_input_filename
!----------------------------------------
```

any keyword with valid syntax
the first string in this line is the name of the input file
corresponding end_keyword with valid syntax

*Example*
Several examples are given in the README.md file.

```
!---------------------------------------------------------------------!
$material                                                 required    !
 material-number                         integer          required    !
 cluster-numbers                         integer_array    required    !
 material-name                           character        required    !
 alloy-function                          character        optional      CHOICE[constant,linear]
 growth-coordinate-axis                  integer_array    optional      CHOICE[0 0 1,1 0 0,0 1 0]
 alloy-concentration                     double           optional    !
 lattice-constants                       double_array     optional    !
 crystal-type                            character        optional      CHOICE[zincblende,wurtzite]
 use-material-parameters-from-database   logical          optional      CHOICE[.TRUE.,.FALSE.]
$end_material                                             required    !
!---------------------------------------------------------------------!
```

**Note: The first specifier after the starting keyword must be required input.**

An input file looks like this:

```
!---------------------------------------------------------------------!
! You can write comments.
# This is also a comment.
/* This is also a comment.
!---------------------------------------------------------------------!
$material

 material-number                         = 1                          ! material no. 1
 cluster-numbers                         = 1 3 5 6
 material-name                           = Al(x)Ga(1-x)As
 alloy-function                          = constant
 growth-coordinate-axis                  = 0 0 1
 alloy-concentration                     = 0.3    ! You can write 0.3, 0.3d0 or 0.3e0. It will always be treated as double.
 band-gaps                               = 1.4  2.0  3.0
 crystal-type                            = zincblende
 use-material-parameters-from-database   = .TRUE.

 !-----------------------------------------------------------------------------------
 ! Now we define material no. 2.
 ! The first specifier 'material-number' acts as a separator for new input sequence.
 !-----------------------------------------------------------------------------------
 material-number                         = 2
 cluster-numbers                         = 2 4
 material-name                           = GaAs

 material-number                         = 3                          ! material no. 3
 cluster-numbers                         = 7 8
 material-name                           = AlAs

 material-number = 4   cluster-numbers = 9    material-name = GaAs    ! This is a comment.
 material-number = 5   cluster-numbers = 10   material-name = AlAs
 material-number = 6   cluster-numbers = 11   material-name = GaAs

$end_material                                                         ! This is matching end keyword.
!---------------------------------------------------------------------!
```
Note: The sum of all specifiers corresponding to one keyword is referred to as input sequence in the following.

Note: The = sign after each specifier is required.
You can use another special character instead of this.
The special character used is defined in MODULE parameters.
The number of input values for array valued specifiers is arbitrary.
If the same specifier appears twice or more within one input sequence, the last value is used for single valued input.
For array valued input, the additional values are added.
However, for the separation specifiers (for a definition see below), this rule does not apply by definition.

You can define predefined options using the optional argument CHOICE e.g. CHOICE[.TRUE.,.FALSE.], CHOICE[1 0 0,0 1 0,0 0 1] or CHOICE.[zincblende,wurtzite].

If the executable with the option -debuglevel 1000, then the file keywords.xml is generated which includes all allowed keywords, specifiers and choices which are used by nextnanomat for its auto completion feature.

*Rules*

In the input file, the first specifier after the starting keyword must be the same as the first specifier after the starting keyword in the definition file keywords.val.
Due to this limitation, this specifier can be used as a separator for a new input sequence within a start and end keyword structure.
Each time, this specifier appears, the beginning of a new input sequence is assumed.
These special specifiers are named *separation specifiers*.
Otherwise, the ordering is arbitrary.
Keywords and specifiers may be in the same line or spread over multiple input lines.
Line breaks are allowed before and after any data value, the = signs and before and after keywords and specifiers.
Blanks at the beginning of a line are not significant.
For input of array type, the numbers must be separated by blanks.

## Parser usage

To read and analyze the input file, a call to SUBROUTINE read_and_analyze_input is required. No argument list is required.

*Data value extraction*

To extract data for a given specifier, a generic subroutine get_data(....) is supplied.

```
SUBROUTINE get_data(keyword,new,specifier,cont,data,pres,line,last)
```

In the calling routine, two modules must be included by the USE statement:

```
USE parameters, ONLY: Data_len
USE generic_get_data
```
length specification for character variables keyword and specifier
interface to generic subroutine get_data(....)

Argument list: Input variables
```
LOGICAL               :: new
LOGICAL               :: cont
CHARACTER(Data_len/3) :: keyword
CHARACTER(Data_len/3) :: specifier 
```

new: .TRUE.  start new search for keyword
new: .FALSE. stay at actual keyword
At first entry in subroutine get_data new must be set to .TRUE.
cont
.TRUE.  search for specifier in next input sequence
.FALSE. search in actual input sequence
keyword
string, containing keyword to be searched for (maximum length 267/3)
specifier
string, containing specifier, for which data value is requested (maximum length 267/3)

Informative output variables:

```
INTEGER :: line
LOGICAL :: pres
LOGICAL :: last 
```

line: line number in input file, where value was found.
pres: .TRUE. if a value for actual specifier was found; .FALSE. otherwise
last: .TRUE. if last input sequence for given keyword was read.

*Generic output*

The variable data in the argument list is representative for one of the possible data type listed beneath for a generic call.

```
INTEGER                       :: ival
REAL(4)                       :: xsval   ! single
LOGICAL                       :: loval
REAL(8)                       :: xdval   ! double
CHARACTER(Data_len/3)         :: caval
INTEGER, DIMENSION(:),POINTER :: inarval
REAL(4), DIMENSION(:),POINTER :: xsarval ! single
REAL(8), DIMENSION(:),POINTER :: xdarval ! double
```

The generic argument must be of the same type as the data type of the requested specifier.


## Input parser: General program flow

This is a description how the main driving routine (MODULE input_driver_module) works (used for reading input parameters, database information as well as processing and checking the corresponding quantities).
The main driving routine for reading input parameters, database information as well as processing and checking the corresponding quantities is input_driver.f90.

```
!---------------------------------------------------!
    CALL read_and_analyze_input                     ! file: parser.f90 
!---------------------------------------------------!
! requires only modules contained in file parser.f90

!---------------------------------------------------!
    CALL d_read_and_analyze_input                   ! file: data_base_builder.f90 
!---------------------------------------------------!
! requires only modules contained in file data_base_builder.f90

!---------------------------------------------------!
    CALL warnings_on_off(warning)                   ! file: warnings_on_off.f90 
!---------------------------------------------------!

!---------------------------------------------------!
    CALL read_constants_and_scaling                 !
!        file: read_constants_and_scaling.f90 
!---------------------------------------------------!
```

## Input parser: Keywords - General introduction to some of the keywords and specifiers including some examples

*Specification of input file name*

The specification of the input filename is done as a first entry in file keywords.val as follows:

```
!---------------------------------------------------!
$input_filename                        optional     !
 input-filename         character      optional     !
$end_input_filename                    optional     !
!---------------------------------------------------!
```

Example

```
!---------------------------------------------------!
$input_filename                        optional     !
 my_input_file.in       character      optional     ! Reads in "my_input_file.in".
$end_input_filename                    optional     !
!---------------------------------------------------!
```
